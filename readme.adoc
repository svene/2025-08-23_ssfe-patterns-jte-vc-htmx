Spring Boot App with HTML Controller

== Usage

- Start Application
- Point browser to: http://localhost:8080/ which should display the Injection-Page

== Further Info

- https://github.com/tschuehly/spring-view-component

== Pattern: Template-Injection

[source,html]
.InjectionPageComponent.jte
----
@import org.svenehrke.demo.web.pages.InjectionPageComponent

@param InjectionPageComponent.Ctx ctx

<!-- SSFE-PATTERN: Template-Injection -->
@template.jte.layout(
content = @`
<h3>Page-1-Component</h3>

<div>${ctx.greeting()}</div>
`)
----

[source,html]
.layout.jte
----
@import gg.jte.Content
@import org.svenehrke.demo.web.pages.InjectionPageComponent
@import org.svenehrke.demo.web.pages.InclusionPageComponent

@param Content content

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
	<title>SSFE-Patterns Demo with JTE-VC</title>
	<script src="/webjars/htmx.org/2.0.4/dist/htmx.js"></script>
</head>

<body>
<nav>
    <a href="${InjectionPageComponent.URL}">Page 1</a>
    <a href="${Page2Component.URL}">Page 2</a>
</nav>
		${content}
</body>

<footer>Footer</footer>
</html>
----


== Pattern: Template-Inclusion

[source,html]
.Page2Component.jte
----
@import org.svenehrke.demo.web.pages.InclusionPageComponent

@param Page2Component.Ctx ctx

<!DOCTYPE html>
<html lang="en">

<!-- SSFE-PATTERN: Template-Inclusion: -->
@template.jte.pagestart()
<body>
<!-- SSFE-PATTERN: Template-Inclusion: -->
@template.jte.pagenavigation()

<h3>Page-2-Component</h3>

<div>${ctx.greeting()}</div>
</body>

<!-- SSFE-PATTERN: Template-Inclusion: -->
@template.jte.pageend()

</html>
----

[source,html]
.pagestart.jte
----
<head>
    <meta charset="UTF-8">
	<title>SSFE-Patterns Demo with JTE-VC</title>
	<script src="/webjars/htmx.org/2.0.4/dist/htmx.js"></script>
</head>
----

[source,html]
.pagenavigation.jte
----
@import org.svenehrke.demo.web.pages.InjectionPageComponent
@import org.svenehrke.demo.web.pages.InclusionPageComponent

<nav>
    <a href="${InjectionPageComponent.URL}">Page 1</a>
    <a href="${Page2Component.URL}">Page 2</a>
</nav>
----

[source,html]
.pageend.jte
----
<footer>Footer</footer>
----

NOTE: JTE does not allow unclosed tags. In the example above this means the <body> start tag cannot be put at the end of pageend.jte for example.
The workaround is to put it into the consumer (Page2Component.jte).
This is acceptable for simple cases.  +
For non-simple cases it is better to use the Template-Injection pattern (using JTE-content).

see: https://github.com/tschuehly/spring-view-component

== Pattern: Insertion

=== Intent
Structure HTML hierarchically using components

=== Implementation

[source,html]
.InsertionPageComponent.jte
----
<div>
    ${new InsertableComponent.Ctx("hello")}
</div>
----

[source,html]
.InsertableComponent.jte
----
@import org.svenehrke.demo.web.components.InsertableComponent

@param InsertableComponent.Ctx ctx

<div>Insertable-Component: ${ctx.greeting()}</div>
----

[source,html]
.InsertionPageComponent.jte, with event-support
----
<div hx-trigger="some-event from:body" hx-get="${InsertableComponent.URL}">
    ${new InsertableComponent.Ctx("hello")}
</div>
----

=== Related Patterns

- Slots

== Pattern: Slots

=== Intent
How to pass content from parent to child.

=== Also Known As

- template
- layout
- socket and plugin
- outside in

=== Applicability

Use when

- a child component has a rather large html content
- a parent component needs to customize a rather small part (or parts) of the child component

=== Implementation

[source,java]
.ParentPageComponent.java
----
class ParentPageComponent {
  public record Ctx(String greeting) implements ViewContext {
		public ChildComponent.Ctx childCtx(Content slot) {
			return new ChildComponent.Ctx(slot);
		}
  }
}
----

[source,html]
.ParentPageComponent.jte, Note that nested contents is possible in JTE
----
@import org.svenehrke.demo.web.pages.ParentPageComponent

@param ParentPageComponent.Ctx ctx

@template.jte.layout(
content = @`
<h3>Parent-Page-Component</h3>
    <div>parent: before</div>
    ${ctx.childCtx(@`
        <div>slot-content from parent. Greeting: ${ctx.greeting()}</div>
    `)}
    <div>parent: after</div>
`)
----

[source,java]
.ChildComponent.java
----
class ChildComponent {
  public record Ctx(Content slot1)  implements ViewContext {}
	// TODO: fragment retrieval support with URL

}
----

[source,html]
.ChildComponent.jte
----
@param ChildComponent.Ctx ctx

<div>child: before</div>
${ctx.slot1()}
<div>child: after</div>
----

[source,html]
.Result
----
<div>parent: before</div>
<div>child: before</div>
<div>slot-content from parent. Greeting: Hello from Parent-Page-content from parent</button>
<div>child: after</div>
<div>parent: after</div>
----

==== Related Patterns

- Insertion

== Pattern: Component Forwarder

=== Intent
forward a request from one component to another

=== Applicability

Use when

- a component recognizes that it cannot
handle the request itself

=== Implementation

[source,java]
.ComponentForwarderPageComponent.java
----
@ViewComponent
@Controller
public class ComponentForwarderPageComponent {
	public static final String URL = "/ui/pages/componentforwarder";
	public record Ctx(String greeting) implements ViewContext { }
	@GetMapping(URL)
	public ViewContext ctx( // Note: needs to return general 'ViewContext' type
		@RequestParam(name = "greeting", required = false,
            defaultValue = "Hello from Component-Forwarder-Page") String greeting
	) {
		if (greeting.contains("forward")) {
			// forward:
			return new InjectionPageComponent.Ctx("via component forwarder");
		} else {
			return new Ctx(greeting);
		}
	}
}
----
== Misc

Nested contents are possible with JTE:

[source,html]
----
@template.jte.layout(
content = @`
    <h3>Parent-Page-Component</h3>
    <div>parent: before</div>
    ${ctx.childCtx(@`
        <div>slot-content from parent. Greeting: ${ctx.greeting()}</div>
    `)}
    <div>parent: after</div>
`)
----


== TODO

- OOB usage
- events usage: `HtmxResponseUtils.setHxTrigger(response, SomeComponent.EVENT_URL_CHANGED);`
- keep frontendstate in hidden input fields ?
